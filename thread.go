// Code generated by Fern. DO NOT EDIT.

package zep

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/getzep/zep-go/v3/internal"
)

type ApidataAddThreadMessagesRequest struct {
	// Optional list of role types to ignore when adding messages to graph memory.
	// The message itself will still be added, retained and used as context for messages
	// that are added to a user's graph.
	IgnoreRoles []ApidataRoleType `json:"ignore_roles,omitempty" url:"-"`
	// A list of message objects, where each message contains a role and content.
	Messages []*ApidataMessage `json:"messages,omitempty" url:"-"`
	// Optionally return memory context relevant to the most recent messages.
	ReturnContext *bool `json:"return_context,omitempty" url:"-"`
}

type ModelsCreateThreadRequest struct {
	// The unique identifier of the thread.
	ThreadID string `json:"thread_id" url:"-"`
	// The unique identifier of the user associated with the thread
	UserID string `json:"user_id" url:"-"`
}

type ThreadGetRequest struct {
	// Limit the number of results returned
	Limit *int `json:"-" url:"limit,omitempty"`
	// Cursor for pagination
	Cursor *int `json:"-" url:"cursor,omitempty"`
}

type ThreadGetUserContextRequest struct {
	// The number of most recent memory entries to retrieve.
	Lastn *int `json:"-" url:"lastn,omitempty"`
	// The minimum rating by which to filter relevant facts.
	MinRating *float64 `json:"-" url:"minRating,omitempty"`
	// If true, bypasses context summarization and returns raw search results.
	Fast *bool `json:"-" url:"fast,omitempty"`
}

type ThreadListAllRequest struct {
	// Page number for pagination, starting from 1
	PageNumber *int `json:"-" url:"page_number,omitempty"`
	// Number of threads to retrieve per page.
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// Field to order the results by: created_at, updated_at, user_id, thread_id.
	OrderBy *string `json:"-" url:"order_by,omitempty"`
	// Order direction: true for ascending, false for descending.
	Asc *bool `json:"-" url:"asc,omitempty"`
}

type ApidataAddThreadMessagesResponse struct {
	Context *string `json:"context,omitempty" url:"context,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApidataAddThreadMessagesResponse) GetContext() *string {
	if a == nil {
		return nil
	}
	return a.Context
}

func (a *ApidataAddThreadMessagesResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApidataAddThreadMessagesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ApidataAddThreadMessagesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApidataAddThreadMessagesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApidataAddThreadMessagesResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApidataMessage struct {
	// The content of the message.
	Content string `json:"content" url:"content"`
	// The timestamp of when the message was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The metadata associated with the message.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Whether the message has been processed.
	Processed *bool `json:"processed,omitempty" url:"processed,omitempty"`
	// Customizable role of the sender of the message (e.g., "john", "sales_agent").
	Role *string `json:"role,omitempty" url:"role,omitempty"`
	// The type of the role (e.g., "user", "system").
	RoleType ApidataRoleType `json:"role_type" url:"role_type"`
	// Deprecated
	TokenCount *int `json:"token_count,omitempty" url:"token_count,omitempty"`
	// Deprecated
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The unique identifier of the message.
	UUID *string `json:"uuid,omitempty" url:"uuid,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApidataMessage) GetContent() string {
	if a == nil {
		return ""
	}
	return a.Content
}

func (a *ApidataMessage) GetCreatedAt() *string {
	if a == nil {
		return nil
	}
	return a.CreatedAt
}

func (a *ApidataMessage) GetMetadata() map[string]interface{} {
	if a == nil {
		return nil
	}
	return a.Metadata
}

func (a *ApidataMessage) GetProcessed() *bool {
	if a == nil {
		return nil
	}
	return a.Processed
}

func (a *ApidataMessage) GetRole() *string {
	if a == nil {
		return nil
	}
	return a.Role
}

func (a *ApidataMessage) GetRoleType() ApidataRoleType {
	if a == nil {
		return ""
	}
	return a.RoleType
}

func (a *ApidataMessage) GetTokenCount() *int {
	if a == nil {
		return nil
	}
	return a.TokenCount
}

func (a *ApidataMessage) GetUpdatedAt() *string {
	if a == nil {
		return nil
	}
	return a.UpdatedAt
}

func (a *ApidataMessage) GetUUID() *string {
	if a == nil {
		return nil
	}
	return a.UUID
}

func (a *ApidataMessage) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApidataMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ApidataMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApidataMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApidataMessage) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApidataMessageListResponse struct {
	// A list of message objects.
	Messages []*ApidataMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// The number of messages returned.
	RowCount *int `json:"row_count,omitempty" url:"row_count,omitempty"`
	// The total number of messages.
	TotalCount *int `json:"total_count,omitempty" url:"total_count,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApidataMessageListResponse) GetMessages() []*ApidataMessage {
	if a == nil {
		return nil
	}
	return a.Messages
}

func (a *ApidataMessageListResponse) GetRowCount() *int {
	if a == nil {
		return nil
	}
	return a.RowCount
}

func (a *ApidataMessageListResponse) GetTotalCount() *int {
	if a == nil {
		return nil
	}
	return a.TotalCount
}

func (a *ApidataMessageListResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApidataMessageListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ApidataMessageListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApidataMessageListResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApidataMessageListResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApidataThread struct {
	CreatedAt   *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	ProjectUUID *string `json:"project_uuid,omitempty" url:"project_uuid,omitempty"`
	ThreadID    *string `json:"thread_id,omitempty" url:"thread_id,omitempty"`
	UserID      *string `json:"user_id,omitempty" url:"user_id,omitempty"`
	UUID        *string `json:"uuid,omitempty" url:"uuid,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApidataThread) GetCreatedAt() *string {
	if a == nil {
		return nil
	}
	return a.CreatedAt
}

func (a *ApidataThread) GetProjectUUID() *string {
	if a == nil {
		return nil
	}
	return a.ProjectUUID
}

func (a *ApidataThread) GetThreadID() *string {
	if a == nil {
		return nil
	}
	return a.ThreadID
}

func (a *ApidataThread) GetUserID() *string {
	if a == nil {
		return nil
	}
	return a.UserID
}

func (a *ApidataThread) GetUUID() *string {
	if a == nil {
		return nil
	}
	return a.UUID
}

func (a *ApidataThread) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApidataThread) UnmarshalJSON(data []byte) error {
	type unmarshaler ApidataThread
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApidataThread(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApidataThread) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApidataThreadContextResponse struct {
	// Memory context containing relevant facts and entities for the session. Can be put into the prompt directly.
	Context *string `json:"context,omitempty" url:"context,omitempty"`
	// A list of message objects, where each message contains a role and content. Only last_n messages will be returned
	Messages []*ApidataMessage `json:"messages,omitempty" url:"messages,omitempty"`
	// Most relevant facts to the recent messages in the session.
	RelevantFacts []*ApidataFact `json:"relevant_facts,omitempty" url:"relevant_facts,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApidataThreadContextResponse) GetContext() *string {
	if a == nil {
		return nil
	}
	return a.Context
}

func (a *ApidataThreadContextResponse) GetMessages() []*ApidataMessage {
	if a == nil {
		return nil
	}
	return a.Messages
}

func (a *ApidataThreadContextResponse) GetRelevantFacts() []*ApidataFact {
	if a == nil {
		return nil
	}
	return a.RelevantFacts
}

func (a *ApidataThreadContextResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApidataThreadContextResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ApidataThreadContextResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApidataThreadContextResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApidataThreadContextResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApidataThreadListResponse struct {
	ResponseCount *int             `json:"response_count,omitempty" url:"response_count,omitempty"`
	Thread        []*ApidataThread `json:"thread,omitempty" url:"thread,omitempty"`
	TotalCount    *int             `json:"total_count,omitempty" url:"total_count,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApidataThreadListResponse) GetResponseCount() *int {
	if a == nil {
		return nil
	}
	return a.ResponseCount
}

func (a *ApidataThreadListResponse) GetThread() []*ApidataThread {
	if a == nil {
		return nil
	}
	return a.Thread
}

func (a *ApidataThreadListResponse) GetTotalCount() *int {
	if a == nil {
		return nil
	}
	return a.TotalCount
}

func (a *ApidataThreadListResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApidataThreadListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ApidataThreadListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApidataThreadListResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApidataThreadListResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}
