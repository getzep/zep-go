// Code generated by Fern. DO NOT EDIT.

package client

import (
	context "context"
	v3 "github.com/getzep/zep-go/v3"
	core "github.com/getzep/zep-go/v3/core"
	edge "github.com/getzep/zep-go/v3/graph/edge"
	episode "github.com/getzep/zep-go/v3/graph/episode"
	node "github.com/getzep/zep-go/v3/graph/node"
	internal "github.com/getzep/zep-go/v3/internal"
	option "github.com/getzep/zep-go/v3/option"
	http "net/http"
	os "os"
)

type Client struct {
	WithRawResponse *RawClient
	Edge            *edge.Client
	Episode         *episode.Client
	Node            *node.Client

	baseURL string
	caller  *internal.Caller
	header  http.Header
}

func NewClient(opts ...option.RequestOption) *Client {
	options := core.NewRequestOptions(opts...)
	if options.APIKey == "" {
		options.APIKey = os.Getenv("ZEP_API_KEY")
	}
	return &Client{
		Edge:            edge.NewClient(opts...),
		Episode:         episode.NewClient(opts...),
		Node:            node.NewClient(opts...),
		WithRawResponse: NewRawClient(options),
		baseURL:         options.BaseURL,
		caller: internal.NewCaller(
			&internal.CallerParams{
				Client:      options.HTTPClient,
				MaxAttempts: options.MaxAttempts,
			},
		),
		header: options.ToHeader(),
	}
}

// Returns all entity types for a project, user, or graph.
func (c *Client) ListEntityTypes(
	ctx context.Context,
	request *v3.GraphListEntityTypesRequest,
	opts ...option.RequestOption,
) (*v3.EntityTypeResponse, error) {
	response, err := c.WithRawResponse.ListEntityTypes(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Sets the entity types for multiple users and graphs, replacing any existing ones.
func (c *Client) SetEntityTypesInternal(
	ctx context.Context,
	request *v3.EntityTypeRequest,
	opts ...option.RequestOption,
) (*v3.SuccessResponse, error) {
	response, err := c.WithRawResponse.SetEntityTypesInternal(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Add data to the graph.
func (c *Client) Add(
	ctx context.Context,
	request *v3.AddDataRequest,
	opts ...option.RequestOption,
) (*v3.Episode, error) {
	response, err := c.WithRawResponse.Add(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Add data to the graph in batch mode, processing episodes concurrently. Use only for data that is insensitive to processing order.
func (c *Client) AddBatch(
	ctx context.Context,
	request *v3.AddDataBatchRequest,
	opts ...option.RequestOption,
) ([]*v3.Episode, error) {
	response, err := c.WithRawResponse.AddBatch(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Add a fact triple for a user or group
func (c *Client) AddFactTriple(
	ctx context.Context,
	request *v3.AddTripleRequest,
	opts ...option.RequestOption,
) (*v3.AddTripleResponse, error) {
	response, err := c.WithRawResponse.AddFactTriple(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Clone a user or group graph.
func (c *Client) Clone(
	ctx context.Context,
	request *v3.CloneGraphRequest,
	opts ...option.RequestOption,
) (*v3.CloneGraphResponse, error) {
	response, err := c.WithRawResponse.Clone(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Creates a new graph.
func (c *Client) Create(
	ctx context.Context,
	request *v3.CreateGraphRequest,
	opts ...option.RequestOption,
) (*v3.Graph, error) {
	response, err := c.WithRawResponse.Create(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Returns all graphs. In order to list users, use user.list_ordered instead
func (c *Client) ListAll(
	ctx context.Context,
	request *v3.GraphListAllRequest,
	opts ...option.RequestOption,
) (*v3.GraphListResponse, error) {
	response, err := c.WithRawResponse.ListAll(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Perform a graph search query.
func (c *Client) Search(
	ctx context.Context,
	request *v3.GraphSearchQuery,
	opts ...option.RequestOption,
) (*v3.GraphSearchResults, error) {
	response, err := c.WithRawResponse.Search(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Returns a graph.
func (c *Client) Get(
	ctx context.Context,
	// The graph_id of the graph to get.
	graphID string,
	opts ...option.RequestOption,
) (*v3.Graph, error) {
	response, err := c.WithRawResponse.Get(
		ctx,
		graphID,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Deletes a graph. If you would like to delete a user graph, make sure to use user.delete instead.
func (c *Client) Delete(
	ctx context.Context,
	// Graph ID
	graphID string,
	opts ...option.RequestOption,
) (*v3.SuccessResponse, error) {
	response, err := c.WithRawResponse.Delete(
		ctx,
		graphID,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Updates information about a graph.
func (c *Client) Update(
	ctx context.Context,
	// Graph ID
	graphID string,
	request *v3.UpdateGraphRequest,
	opts ...option.RequestOption,
) (*v3.Graph, error) {
	response, err := c.WithRawResponse.Update(
		ctx,
		graphID,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Sets custom entity and edge types for your graph. This wrapper method
// provides a clean interface for defining your graph schema with custom
// entity and edge types.
//
// See the [full documentation](/customizing-graph-structure#setting-entity-and-edge-types) for details.
func (c *Client) SetOntology(
	ctx context.Context,
	request *v3.GraphSetOntologyRequest,
	opts ...option.RequestOption,
) (*v3.SuccessResponse, error) {
	response, err := c.WithRawResponse.SetOntology(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Retrieves the current entity and edge types configured for your graph.
//
// See the [full documentation](/customizing-graph-structure) for details.
func (c *Client) ListOntology(
	ctx context.Context,
	opts ...option.RequestOption,
) (*v3.EntityTypeResponse, error) {
	response, err := c.WithRawResponse.ListOntology(
		ctx,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}
