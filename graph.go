// Code generated by Fern. DO NOT EDIT.

package zep

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/getzep/zep-go/v3/internal"
)

type ApidataAddDataRequest struct {
	CreatedAt *string `json:"created_at,omitempty" url:"-"`
	Data      string  `json:"data" url:"-"`
	// graph_id is the ID of the graph to which the data will be added. If adding to the user graph, please use user_id field instead.
	GraphID           *string             `json:"graph_id,omitempty" url:"-"`
	SourceDescription *string             `json:"source_description,omitempty" url:"-"`
	Type              ModelsGraphDataType `json:"type" url:"-"`
	// User ID is the ID of the user to which the data will be added. If not adding to a user graph, please use graph_id field instead.
	UserID *string `json:"user_id,omitempty" url:"-"`
}

type ApidataAddDataBatchRequest struct {
	Episodes []*ApidataEpisodeData `json:"episodes,omitempty" url:"-"`
	// graph_id is the ID of the graph to which the data will be added. If adding to the user graph, please use user_id field instead.
	GraphID *string `json:"graph_id,omitempty" url:"-"`
	// User ID is the ID of the user to which the data will be added. If not adding to a user graph, please use graph_id field instead.
	UserID *string `json:"user_id,omitempty" url:"-"`
}

type GraphitiAddTripleRequest struct {
	// The timestamp of the message
	CreatedAt *string `json:"created_at,omitempty" url:"-"`
	// The time (if any) at which the edge expires
	ExpiredAt *string `json:"expired_at,omitempty" url:"-"`
	// The fact relating the two nodes that this edge represents
	Fact string `json:"fact" url:"-"`
	// The name of the edge to add. Should be all caps using snake case (eg RELATES_TO)
	FactName string `json:"fact_name" url:"-"`
	// The uuid of the edge to add
	FactUUID *string `json:"fact_uuid,omitempty" url:"-"`
	GraphID  *string `json:"graph_id,omitempty" url:"-"`
	// The time (if any) at which the fact stops being true
	InvalidAt *string `json:"invalid_at,omitempty" url:"-"`
	// The name of the source node to add
	SourceNodeName *string `json:"source_node_name,omitempty" url:"-"`
	// The summary of the source node to add
	SourceNodeSummary *string `json:"source_node_summary,omitempty" url:"-"`
	// The source node uuid
	SourceNodeUUID *string `json:"source_node_uuid,omitempty" url:"-"`
	// The name of the target node to add
	TargetNodeName string `json:"target_node_name" url:"-"`
	// The summary of the target node to add
	TargetNodeSummary *string `json:"target_node_summary,omitempty" url:"-"`
	// The target node uuid
	TargetNodeUUID *string `json:"target_node_uuid,omitempty" url:"-"`
	UserID         *string `json:"user_id,omitempty" url:"-"`
	// The time at which the fact becomes true
	ValidAt *string `json:"valid_at,omitempty" url:"-"`
}

type ApidataCloneGraphRequest struct {
	// source_graph_id is the ID of the graph to be cloned. Required if source_user_id is not provided
	SourceGraphID *string `json:"source_graph_id,omitempty" url:"-"`
	// user_id of the user whose graph is being cloned. Required if source_graph_id is not provided
	SourceUserID *string `json:"source_user_id,omitempty" url:"-"`
	// target_graph_id is the ID to be set on the cloned graph. Must not point to an existing graph. Required if target_user_id is not provided.
	TargetGraphID *string `json:"target_graph_id,omitempty" url:"-"`
	// user_id to be set on the cloned user. Must not point to an existing user. Required if target_graph_id is not provided.
	TargetUserID *string `json:"target_user_id,omitempty" url:"-"`
}

type ApidataCreateGraphRequest struct {
	Description           *string                       `json:"description,omitempty" url:"-"`
	FactRatingInstruction *ApidataFactRatingInstruction `json:"fact_rating_instruction,omitempty" url:"-"`
	GraphID               string                        `json:"graph_id" url:"-"`
	Name                  *string                       `json:"name,omitempty" url:"-"`
}

type GraphitiGraphSearchQuery struct {
	// Nodes that are the origins of the BFS searches
	BfsOriginNodeUUIDs []string `json:"bfs_origin_node_uuids,omitempty" url:"-"`
	// Node to rerank around for node distance reranking
	CenterNodeUUID *string `json:"center_node_uuid,omitempty" url:"-"`
	// The graph_id to search in. When searching user graph, please use user_id instead.
	GraphID *string `json:"graph_id,omitempty" url:"-"`
	// The maximum number of facts to retrieve. Defaults to 10. Limited to 50.
	Limit *int `json:"limit,omitempty" url:"-"`
	// The minimum rating by which to filter relevant facts
	MinFactRating *float64 `json:"min_fact_rating,omitempty" url:"-"`
	// Deprecated
	MinScore *float64 `json:"min_score,omitempty" url:"-"`
	// weighting for maximal marginal relevance
	MmrLambda *float64 `json:"mmr_lambda,omitempty" url:"-"`
	// The string to search for (required)
	Query string `json:"query" url:"-"`
	// Defaults to RRF
	Reranker *GraphitiReranker `json:"reranker,omitempty" url:"-"`
	// Defaults to Edges. Communities will be added in the future.
	Scope *GraphitiGraphSearchScope `json:"scope,omitempty" url:"-"`
	// Search filters to apply to the search
	SearchFilters *GraphitiSearchFilters `json:"search_filters,omitempty" url:"-"`
	// The user_id when searching user graph. If not searching user graph, please use graph_id instead.
	UserID *string `json:"user_id,omitempty" url:"-"`
}

type ApidataEntityTypeRequest struct {
	EdgeTypes   []*ApidataEdgeType   `json:"edge_types,omitempty" url:"-"`
	EntityTypes []*ApidataEntityType `json:"entity_types,omitempty" url:"-"`
}

type ApidataCloneGraphResponse struct {
	// graph_id is the ID of the cloned graph
	GraphID *string `json:"graph_id,omitempty" url:"graph_id,omitempty"`
	UserID  *string `json:"user_id,omitempty" url:"user_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApidataCloneGraphResponse) GetGraphID() *string {
	if a == nil {
		return nil
	}
	return a.GraphID
}

func (a *ApidataCloneGraphResponse) GetUserID() *string {
	if a == nil {
		return nil
	}
	return a.UserID
}

func (a *ApidataCloneGraphResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApidataCloneGraphResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ApidataCloneGraphResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApidataCloneGraphResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApidataCloneGraphResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApidataEdgeType struct {
	Description   string                           `json:"description" url:"description"`
	Name          string                           `json:"name" url:"name"`
	Properties    []*ApidataEntityProperty         `json:"properties,omitempty" url:"properties,omitempty"`
	SourceTargets []*ApidataEntityEdgeSourceTarget `json:"source_targets,omitempty" url:"source_targets,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApidataEdgeType) GetDescription() string {
	if a == nil {
		return ""
	}
	return a.Description
}

func (a *ApidataEdgeType) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *ApidataEdgeType) GetProperties() []*ApidataEntityProperty {
	if a == nil {
		return nil
	}
	return a.Properties
}

func (a *ApidataEdgeType) GetSourceTargets() []*ApidataEntityEdgeSourceTarget {
	if a == nil {
		return nil
	}
	return a.SourceTargets
}

func (a *ApidataEdgeType) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApidataEdgeType) UnmarshalJSON(data []byte) error {
	type unmarshaler ApidataEdgeType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApidataEdgeType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApidataEdgeType) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApidataEntityEdgeSourceTarget struct {
	// Source represents the originating node identifier in the edge type relationship. (optional)
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// Target represents the target node identifier in the edge type relationship. (optional)
	Target *string `json:"target,omitempty" url:"target,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApidataEntityEdgeSourceTarget) GetSource() *string {
	if a == nil {
		return nil
	}
	return a.Source
}

func (a *ApidataEntityEdgeSourceTarget) GetTarget() *string {
	if a == nil {
		return nil
	}
	return a.Target
}

func (a *ApidataEntityEdgeSourceTarget) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApidataEntityEdgeSourceTarget) UnmarshalJSON(data []byte) error {
	type unmarshaler ApidataEntityEdgeSourceTarget
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApidataEntityEdgeSourceTarget(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApidataEntityEdgeSourceTarget) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApidataEntityProperty struct {
	Description string                   `json:"description" url:"description"`
	Name        string                   `json:"name" url:"name"`
	Type        ModelsEntityPropertyType `json:"type" url:"type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApidataEntityProperty) GetDescription() string {
	if a == nil {
		return ""
	}
	return a.Description
}

func (a *ApidataEntityProperty) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *ApidataEntityProperty) GetType() ModelsEntityPropertyType {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *ApidataEntityProperty) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApidataEntityProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler ApidataEntityProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApidataEntityProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApidataEntityProperty) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApidataEntityType struct {
	Description string                   `json:"description" url:"description"`
	Name        string                   `json:"name" url:"name"`
	Properties  []*ApidataEntityProperty `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApidataEntityType) GetDescription() string {
	if a == nil {
		return ""
	}
	return a.Description
}

func (a *ApidataEntityType) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *ApidataEntityType) GetProperties() []*ApidataEntityProperty {
	if a == nil {
		return nil
	}
	return a.Properties
}

func (a *ApidataEntityType) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApidataEntityType) UnmarshalJSON(data []byte) error {
	type unmarshaler ApidataEntityType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApidataEntityType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApidataEntityType) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApidataEntityTypeResponse struct {
	EdgeTypes   []*ApidataEdgeType   `json:"edge_types,omitempty" url:"edge_types,omitempty"`
	EntityTypes []*ApidataEntityType `json:"entity_types,omitempty" url:"entity_types,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApidataEntityTypeResponse) GetEdgeTypes() []*ApidataEdgeType {
	if a == nil {
		return nil
	}
	return a.EdgeTypes
}

func (a *ApidataEntityTypeResponse) GetEntityTypes() []*ApidataEntityType {
	if a == nil {
		return nil
	}
	return a.EntityTypes
}

func (a *ApidataEntityTypeResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApidataEntityTypeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ApidataEntityTypeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApidataEntityTypeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApidataEntityTypeResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApidataEpisodeData struct {
	CreatedAt         *string             `json:"created_at,omitempty" url:"created_at,omitempty"`
	Data              string              `json:"data" url:"data"`
	SourceDescription *string             `json:"source_description,omitempty" url:"source_description,omitempty"`
	Type              ModelsGraphDataType `json:"type" url:"type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApidataEpisodeData) GetCreatedAt() *string {
	if a == nil {
		return nil
	}
	return a.CreatedAt
}

func (a *ApidataEpisodeData) GetData() string {
	if a == nil {
		return ""
	}
	return a.Data
}

func (a *ApidataEpisodeData) GetSourceDescription() *string {
	if a == nil {
		return nil
	}
	return a.SourceDescription
}

func (a *ApidataEpisodeData) GetType() ModelsGraphDataType {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *ApidataEpisodeData) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApidataEpisodeData) UnmarshalJSON(data []byte) error {
	type unmarshaler ApidataEpisodeData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApidataEpisodeData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApidataEpisodeData) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApidataGraph struct {
	CreatedAt             *string                       `json:"created_at,omitempty" url:"created_at,omitempty"`
	Description           *string                       `json:"description,omitempty" url:"description,omitempty"`
	FactRatingInstruction *ApidataFactRatingInstruction `json:"fact_rating_instruction,omitempty" url:"fact_rating_instruction,omitempty"`
	GraphID               *string                       `json:"graph_id,omitempty" url:"graph_id,omitempty"`
	ID                    *int                          `json:"id,omitempty" url:"id,omitempty"`
	Name                  *string                       `json:"name,omitempty" url:"name,omitempty"`
	ProjectUUID           *string                       `json:"project_uuid,omitempty" url:"project_uuid,omitempty"`
	UUID                  *string                       `json:"uuid,omitempty" url:"uuid,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApidataGraph) GetCreatedAt() *string {
	if a == nil {
		return nil
	}
	return a.CreatedAt
}

func (a *ApidataGraph) GetDescription() *string {
	if a == nil {
		return nil
	}
	return a.Description
}

func (a *ApidataGraph) GetFactRatingInstruction() *ApidataFactRatingInstruction {
	if a == nil {
		return nil
	}
	return a.FactRatingInstruction
}

func (a *ApidataGraph) GetGraphID() *string {
	if a == nil {
		return nil
	}
	return a.GraphID
}

func (a *ApidataGraph) GetID() *int {
	if a == nil {
		return nil
	}
	return a.ID
}

func (a *ApidataGraph) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *ApidataGraph) GetProjectUUID() *string {
	if a == nil {
		return nil
	}
	return a.ProjectUUID
}

func (a *ApidataGraph) GetUUID() *string {
	if a == nil {
		return nil
	}
	return a.UUID
}

func (a *ApidataGraph) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApidataGraph) UnmarshalJSON(data []byte) error {
	type unmarshaler ApidataGraph
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApidataGraph(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApidataGraph) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApidataGraphSearchResults struct {
	Edges    []*GraphitiEntityEdge  `json:"edges,omitempty" url:"edges,omitempty"`
	Episodes []*ApidataGraphEpisode `json:"episodes,omitempty" url:"episodes,omitempty"`
	Nodes    []*GraphitiEntityNode  `json:"nodes,omitempty" url:"nodes,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ApidataGraphSearchResults) GetEdges() []*GraphitiEntityEdge {
	if a == nil {
		return nil
	}
	return a.Edges
}

func (a *ApidataGraphSearchResults) GetEpisodes() []*ApidataGraphEpisode {
	if a == nil {
		return nil
	}
	return a.Episodes
}

func (a *ApidataGraphSearchResults) GetNodes() []*GraphitiEntityNode {
	if a == nil {
		return nil
	}
	return a.Nodes
}

func (a *ApidataGraphSearchResults) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApidataGraphSearchResults) UnmarshalJSON(data []byte) error {
	type unmarshaler ApidataGraphSearchResults
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApidataGraphSearchResults(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApidataGraphSearchResults) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type GraphitiAddTripleResponse struct {
	Edge       *GraphitiEntityEdge `json:"edge,omitempty" url:"edge,omitempty"`
	SourceNode *GraphitiEntityNode `json:"source_node,omitempty" url:"source_node,omitempty"`
	TargetNode *GraphitiEntityNode `json:"target_node,omitempty" url:"target_node,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GraphitiAddTripleResponse) GetEdge() *GraphitiEntityEdge {
	if g == nil {
		return nil
	}
	return g.Edge
}

func (g *GraphitiAddTripleResponse) GetSourceNode() *GraphitiEntityNode {
	if g == nil {
		return nil
	}
	return g.SourceNode
}

func (g *GraphitiAddTripleResponse) GetTargetNode() *GraphitiEntityNode {
	if g == nil {
		return nil
	}
	return g.TargetNode
}

func (g *GraphitiAddTripleResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GraphitiAddTripleResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GraphitiAddTripleResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GraphitiAddTripleResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GraphitiAddTripleResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GraphitiComparisonOperator string

const (
	GraphitiComparisonOperatorEquals           GraphitiComparisonOperator = "="
	GraphitiComparisonOperatorNotEquals        GraphitiComparisonOperator = "<>"
	GraphitiComparisonOperatorGreaterThan      GraphitiComparisonOperator = ">"
	GraphitiComparisonOperatorLessThan         GraphitiComparisonOperator = "<"
	GraphitiComparisonOperatorGreaterThanEqual GraphitiComparisonOperator = ">="
	GraphitiComparisonOperatorLessThanEqual    GraphitiComparisonOperator = "<="
)

func NewGraphitiComparisonOperatorFromString(s string) (GraphitiComparisonOperator, error) {
	switch s {
	case "=":
		return GraphitiComparisonOperatorEquals, nil
	case "<>":
		return GraphitiComparisonOperatorNotEquals, nil
	case ">":
		return GraphitiComparisonOperatorGreaterThan, nil
	case "<":
		return GraphitiComparisonOperatorLessThan, nil
	case ">=":
		return GraphitiComparisonOperatorGreaterThanEqual, nil
	case "<=":
		return GraphitiComparisonOperatorLessThanEqual, nil
	}
	var t GraphitiComparisonOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GraphitiComparisonOperator) Ptr() *GraphitiComparisonOperator {
	return &g
}

type GraphitiDateFilter struct {
	// Comparison operator for date filter
	ComparisonOperator GraphitiComparisonOperator `json:"comparison_operator" url:"comparison_operator"`
	// Date to filter on
	Date string `json:"date" url:"date"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GraphitiDateFilter) GetComparisonOperator() GraphitiComparisonOperator {
	if g == nil {
		return ""
	}
	return g.ComparisonOperator
}

func (g *GraphitiDateFilter) GetDate() string {
	if g == nil {
		return ""
	}
	return g.Date
}

func (g *GraphitiDateFilter) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GraphitiDateFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler GraphitiDateFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GraphitiDateFilter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GraphitiDateFilter) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GraphitiGraphSearchScope string

const (
	GraphitiGraphSearchScopeEdges    GraphitiGraphSearchScope = "edges"
	GraphitiGraphSearchScopeNodes    GraphitiGraphSearchScope = "nodes"
	GraphitiGraphSearchScopeEpisodes GraphitiGraphSearchScope = "episodes"
)

func NewGraphitiGraphSearchScopeFromString(s string) (GraphitiGraphSearchScope, error) {
	switch s {
	case "edges":
		return GraphitiGraphSearchScopeEdges, nil
	case "nodes":
		return GraphitiGraphSearchScopeNodes, nil
	case "episodes":
		return GraphitiGraphSearchScopeEpisodes, nil
	}
	var t GraphitiGraphSearchScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GraphitiGraphSearchScope) Ptr() *GraphitiGraphSearchScope {
	return &g
}

type GraphitiReranker string

const (
	GraphitiRerankerRrf             GraphitiReranker = "rrf"
	GraphitiRerankerMmr             GraphitiReranker = "mmr"
	GraphitiRerankerNodeDistance    GraphitiReranker = "node_distance"
	GraphitiRerankerEpisodeMentions GraphitiReranker = "episode_mentions"
	GraphitiRerankerCrossEncoder    GraphitiReranker = "cross_encoder"
)

func NewGraphitiRerankerFromString(s string) (GraphitiReranker, error) {
	switch s {
	case "rrf":
		return GraphitiRerankerRrf, nil
	case "mmr":
		return GraphitiRerankerMmr, nil
	case "node_distance":
		return GraphitiRerankerNodeDistance, nil
	case "episode_mentions":
		return GraphitiRerankerEpisodeMentions, nil
	case "cross_encoder":
		return GraphitiRerankerCrossEncoder, nil
	}
	var t GraphitiReranker
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GraphitiReranker) Ptr() *GraphitiReranker {
	return &g
}

type GraphitiSearchFilters struct {
	// 2D array of date filters for the created_at field.
	// The outer array elements are combined with OR logic.
	// The inner array elements are combined with AND logic.
	// Example: [[{">", date1}, {"<", date2}], [{"=", date3}]]
	// This translates to: (created_at > date1 AND created_at < date2) OR (created_at = date3)
	CreatedAt [][]*GraphitiDateFilter `json:"created_at,omitempty" url:"created_at,omitempty"`
	// List of edge types to filter on
	EdgeTypes []string `json:"edge_types,omitempty" url:"edge_types,omitempty"`
	// 2D array of date filters for the expired_at field.
	// The outer array elements are combined with OR logic.
	// The inner array elements are combined with AND logic.
	// Example: [[{">", date1}, {"<", date2}], [{"=", date3}]]
	// This translates to: (expired_at > date1 AND expired_at < date2) OR (expired_at = date3)
	ExpiredAt [][]*GraphitiDateFilter `json:"expired_at,omitempty" url:"expired_at,omitempty"`
	// 2D array of date filters for the invalid_at field.
	// The outer array elements are combined with OR logic.
	// The inner array elements are combined with AND logic.
	// Example: [[{">", date1}, {"<", date2}], [{"=", date3}]]
	// This translates to: (invalid_at > date1 AND invalid_at < date2) OR (invalid_at = date3)
	InvalidAt [][]*GraphitiDateFilter `json:"invalid_at,omitempty" url:"invalid_at,omitempty"`
	// List of node labels to filter on
	NodeLabels []string `json:"node_labels,omitempty" url:"node_labels,omitempty"`
	// 2D array of date filters for the valid_at field.
	// The outer array elements are combined with OR logic.
	// The inner array elements are combined with AND logic.
	// Example: [[{">", date1}, {"<", date2}], [{"=", date3}]]
	// This translates to: (valid_at > date1 AND valid_at < date2) OR (valid_at = date3)
	ValidAt [][]*GraphitiDateFilter `json:"valid_at,omitempty" url:"valid_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GraphitiSearchFilters) GetCreatedAt() [][]*GraphitiDateFilter {
	if g == nil {
		return nil
	}
	return g.CreatedAt
}

func (g *GraphitiSearchFilters) GetEdgeTypes() []string {
	if g == nil {
		return nil
	}
	return g.EdgeTypes
}

func (g *GraphitiSearchFilters) GetExpiredAt() [][]*GraphitiDateFilter {
	if g == nil {
		return nil
	}
	return g.ExpiredAt
}

func (g *GraphitiSearchFilters) GetInvalidAt() [][]*GraphitiDateFilter {
	if g == nil {
		return nil
	}
	return g.InvalidAt
}

func (g *GraphitiSearchFilters) GetNodeLabels() []string {
	if g == nil {
		return nil
	}
	return g.NodeLabels
}

func (g *GraphitiSearchFilters) GetValidAt() [][]*GraphitiDateFilter {
	if g == nil {
		return nil
	}
	return g.ValidAt
}

func (g *GraphitiSearchFilters) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GraphitiSearchFilters) UnmarshalJSON(data []byte) error {
	type unmarshaler GraphitiSearchFilters
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GraphitiSearchFilters(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GraphitiSearchFilters) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ModelsEntityPropertyType string

const (
	ModelsEntityPropertyTypeText    ModelsEntityPropertyType = "Text"
	ModelsEntityPropertyTypeInt     ModelsEntityPropertyType = "Int"
	ModelsEntityPropertyTypeFloat   ModelsEntityPropertyType = "Float"
	ModelsEntityPropertyTypeBoolean ModelsEntityPropertyType = "Boolean"
)

func NewModelsEntityPropertyTypeFromString(s string) (ModelsEntityPropertyType, error) {
	switch s {
	case "Text":
		return ModelsEntityPropertyTypeText, nil
	case "Int":
		return ModelsEntityPropertyTypeInt, nil
	case "Float":
		return ModelsEntityPropertyTypeFloat, nil
	case "Boolean":
		return ModelsEntityPropertyTypeBoolean, nil
	}
	var t ModelsEntityPropertyType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m ModelsEntityPropertyType) Ptr() *ModelsEntityPropertyType {
	return &m
}
