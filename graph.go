// Code generated by Fern. DO NOT EDIT.

package zep

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/getzep/zep-go/v3/internal"
)

type AddDataRequest struct {
	CreatedAt *string `json:"created_at,omitempty" url:"-"`
	Data      string  `json:"data" url:"-"`
	// graph_id is the ID of the graph to which the data will be added. If adding to the user graph, please use user_id field instead.
	GraphID           *string       `json:"graph_id,omitempty" url:"-"`
	SourceDescription *string       `json:"source_description,omitempty" url:"-"`
	Type              GraphDataType `json:"type" url:"-"`
	// User ID is the ID of the user to which the data will be added. If not adding to a user graph, please use graph_id field instead.
	UserID *string `json:"user_id,omitempty" url:"-"`
}

type AddDataBatchRequest struct {
	Episodes []*EpisodeData `json:"episodes,omitempty" url:"-"`
	// graph_id is the ID of the graph to which the data will be added. If adding to the user graph, please use user_id field instead.
	GraphID *string `json:"graph_id,omitempty" url:"-"`
	// User ID is the ID of the user to which the data will be added. If not adding to a user graph, please use graph_id field instead.
	UserID *string `json:"user_id,omitempty" url:"-"`
}

type AddTripleRequest struct {
	// The timestamp of the message
	CreatedAt *string `json:"created_at,omitempty" url:"-"`
	// Additional attributes of the edge. Values must be scalar types (string, number, boolean, or null).
	// Nested objects and arrays are not allowed.
	EdgeAttributes map[string]interface{} `json:"edge_attributes,omitempty" url:"-"`
	// The time (if any) at which the edge expires
	ExpiredAt *string `json:"expired_at,omitempty" url:"-"`
	// The fact relating the two nodes that this edge represents
	Fact string `json:"fact" url:"-"`
	// The name of the edge to add. Should be all caps using snake case (eg RELATES_TO)
	FactName string `json:"fact_name" url:"-"`
	// The uuid of the edge to add
	FactUUID *string `json:"fact_uuid,omitempty" url:"-"`
	GraphID  *string `json:"graph_id,omitempty" url:"-"`
	// The time (if any) at which the fact stops being true
	InvalidAt *string `json:"invalid_at,omitempty" url:"-"`
	// Additional attributes of the source node. Values must be scalar types (string, number, boolean, or null).
	// Nested objects and arrays are not allowed.
	SourceNodeAttributes map[string]interface{} `json:"source_node_attributes,omitempty" url:"-"`
	// The name of the source node to add
	SourceNodeName *string `json:"source_node_name,omitempty" url:"-"`
	// The summary of the source node to add
	SourceNodeSummary *string `json:"source_node_summary,omitempty" url:"-"`
	// The source node uuid
	SourceNodeUUID *string `json:"source_node_uuid,omitempty" url:"-"`
	// Additional attributes of the target node. Values must be scalar types (string, number, boolean, or null).
	// Nested objects and arrays are not allowed.
	TargetNodeAttributes map[string]interface{} `json:"target_node_attributes,omitempty" url:"-"`
	// The name of the target node to add
	TargetNodeName *string `json:"target_node_name,omitempty" url:"-"`
	// The summary of the target node to add
	TargetNodeSummary *string `json:"target_node_summary,omitempty" url:"-"`
	// The target node uuid
	TargetNodeUUID *string `json:"target_node_uuid,omitempty" url:"-"`
	UserID         *string `json:"user_id,omitempty" url:"-"`
	// The time at which the fact becomes true
	ValidAt *string `json:"valid_at,omitempty" url:"-"`
}

type CloneGraphRequest struct {
	// source_graph_id is the ID of the graph to be cloned. Required if source_user_id is not provided
	SourceGraphID *string `json:"source_graph_id,omitempty" url:"-"`
	// user_id of the user whose graph is being cloned. Required if source_graph_id is not provided
	SourceUserID *string `json:"source_user_id,omitempty" url:"-"`
	// target_graph_id is the ID to be set on the cloned graph. Must not point to an existing graph. Required if target_user_id is not provided.
	TargetGraphID *string `json:"target_graph_id,omitempty" url:"-"`
	// user_id to be set on the cloned user. Must not point to an existing user. Required if target_graph_id is not provided.
	TargetUserID *string `json:"target_user_id,omitempty" url:"-"`
}

type CreateGraphRequest struct {
	Description           *string                `json:"description,omitempty" url:"-"`
	FactRatingInstruction *FactRatingInstruction `json:"fact_rating_instruction,omitempty" url:"-"`
	GraphID               string                 `json:"graph_id" url:"-"`
	Name                  *string                `json:"name,omitempty" url:"-"`
}

type GraphListAllRequest struct {
	// Page number for pagination, starting from 1.
	PageNumber *int `json:"-" url:"pageNumber,omitempty"`
	// Number of graphs to retrieve per page.
	PageSize *int `json:"-" url:"pageSize,omitempty"`
}

type GraphListEntityTypesRequest struct {
	// User ID to get user-specific entity types
	UserID *string `json:"-" url:"user_id,omitempty"`
	// Graph ID to get graph-specific entity types
	GraphID *string `json:"-" url:"graph_id,omitempty"`
}

type GraphSearchQuery struct {
	// Nodes that are the origins of the BFS searches
	BfsOriginNodeUUIDs []string `json:"bfs_origin_node_uuids,omitempty" url:"-"`
	// Node to rerank around for node distance reranking
	CenterNodeUUID *string `json:"center_node_uuid,omitempty" url:"-"`
	// The graph_id to search in. When searching user graph, please use user_id instead.
	GraphID *string `json:"graph_id,omitempty" url:"-"`
	// The maximum number of facts to retrieve. Defaults to 10. Limited to 50.
	Limit *int `json:"limit,omitempty" url:"-"`
	// The minimum rating by which to filter relevant facts
	MinFactRating *float64 `json:"min_fact_rating,omitempty" url:"-"`
	// Deprecated
	MinScore *float64 `json:"min_score,omitempty" url:"-"`
	// weighting for maximal marginal relevance
	MmrLambda *float64 `json:"mmr_lambda,omitempty" url:"-"`
	// The string to search for (required)
	Query string `json:"query" url:"-"`
	// Defaults to RRF
	Reranker *Reranker `json:"reranker,omitempty" url:"-"`
	// Defaults to Edges. Communities will be added in the future.
	Scope *GraphSearchScope `json:"scope,omitempty" url:"-"`
	// Search filters to apply to the search
	SearchFilters *SearchFilters `json:"search_filters,omitempty" url:"-"`
	// The user_id when searching user graph. If not searching user graph, please use graph_id instead.
	UserID *string `json:"user_id,omitempty" url:"-"`
}

type EntityTypeRequest struct {
	EdgeTypes   []*EdgeType   `json:"edge_types,omitempty" url:"-"`
	EntityTypes []*EntityType `json:"entity_types,omitempty" url:"-"`
	GraphIDs    []string      `json:"graph_ids,omitempty" url:"-"`
	UserIDs     []string      `json:"user_ids,omitempty" url:"-"`
}

type AddTripleResponse struct {
	Edge       *EntityEdge `json:"edge,omitempty" url:"edge,omitempty"`
	SourceNode *EntityNode `json:"source_node,omitempty" url:"source_node,omitempty"`
	TargetNode *EntityNode `json:"target_node,omitempty" url:"target_node,omitempty"`
	// Task ID of the add triple task
	TaskID *string `json:"task_id,omitempty" url:"task_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AddTripleResponse) GetEdge() *EntityEdge {
	if a == nil {
		return nil
	}
	return a.Edge
}

func (a *AddTripleResponse) GetSourceNode() *EntityNode {
	if a == nil {
		return nil
	}
	return a.SourceNode
}

func (a *AddTripleResponse) GetTargetNode() *EntityNode {
	if a == nil {
		return nil
	}
	return a.TargetNode
}

func (a *AddTripleResponse) GetTaskID() *string {
	if a == nil {
		return nil
	}
	return a.TaskID
}

func (a *AddTripleResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddTripleResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AddTripleResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddTripleResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddTripleResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type CloneGraphResponse struct {
	// graph_id is the ID of the cloned graph
	GraphID *string `json:"graph_id,omitempty" url:"graph_id,omitempty"`
	// Task ID of the clone graph task
	TaskID *string `json:"task_id,omitempty" url:"task_id,omitempty"`
	UserID *string `json:"user_id,omitempty" url:"user_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CloneGraphResponse) GetGraphID() *string {
	if c == nil {
		return nil
	}
	return c.GraphID
}

func (c *CloneGraphResponse) GetTaskID() *string {
	if c == nil {
		return nil
	}
	return c.TaskID
}

func (c *CloneGraphResponse) GetUserID() *string {
	if c == nil {
		return nil
	}
	return c.UserID
}

func (c *CloneGraphResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CloneGraphResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CloneGraphResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CloneGraphResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CloneGraphResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ComparisonOperator string

const (
	ComparisonOperatorEquals           ComparisonOperator = "="
	ComparisonOperatorNotEquals        ComparisonOperator = "<>"
	ComparisonOperatorGreaterThan      ComparisonOperator = ">"
	ComparisonOperatorLessThan         ComparisonOperator = "<"
	ComparisonOperatorGreaterThanEqual ComparisonOperator = ">="
	ComparisonOperatorLessThanEqual    ComparisonOperator = "<="
	ComparisonOperatorIsNull           ComparisonOperator = "IS NULL"
	ComparisonOperatorIsNotNull        ComparisonOperator = "IS NOT NULL"
)

func NewComparisonOperatorFromString(s string) (ComparisonOperator, error) {
	switch s {
	case "=":
		return ComparisonOperatorEquals, nil
	case "<>":
		return ComparisonOperatorNotEquals, nil
	case ">":
		return ComparisonOperatorGreaterThan, nil
	case "<":
		return ComparisonOperatorLessThan, nil
	case ">=":
		return ComparisonOperatorGreaterThanEqual, nil
	case "<=":
		return ComparisonOperatorLessThanEqual, nil
	case "IS NULL":
		return ComparisonOperatorIsNull, nil
	case "IS NOT NULL":
		return ComparisonOperatorIsNotNull, nil
	}
	var t ComparisonOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ComparisonOperator) Ptr() *ComparisonOperator {
	return &c
}

type DateFilter struct {
	// Comparison operator for date filter
	ComparisonOperator ComparisonOperator `json:"comparison_operator" url:"comparison_operator"`
	// Date to filter on. Required for non-null operators (=, <>, >, <, >=, <=).
	// Should be omitted for IS NULL and IS NOT NULL operators.
	Date *string `json:"date,omitempty" url:"date,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DateFilter) GetComparisonOperator() ComparisonOperator {
	if d == nil {
		return ""
	}
	return d.ComparisonOperator
}

func (d *DateFilter) GetDate() *string {
	if d == nil {
		return nil
	}
	return d.Date
}

func (d *DateFilter) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DateFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler DateFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DateFilter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DateFilter) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EdgeType struct {
	Description   string                    `json:"description" url:"description"`
	Name          string                    `json:"name" url:"name"`
	Properties    []*EntityProperty         `json:"properties,omitempty" url:"properties,omitempty"`
	SourceTargets []*EntityEdgeSourceTarget `json:"source_targets,omitempty" url:"source_targets,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EdgeType) GetDescription() string {
	if e == nil {
		return ""
	}
	return e.Description
}

func (e *EdgeType) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

func (e *EdgeType) GetProperties() []*EntityProperty {
	if e == nil {
		return nil
	}
	return e.Properties
}

func (e *EdgeType) GetSourceTargets() []*EntityEdgeSourceTarget {
	if e == nil {
		return nil
	}
	return e.SourceTargets
}

func (e *EdgeType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EdgeType) UnmarshalJSON(data []byte) error {
	type unmarshaler EdgeType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EdgeType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EdgeType) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityEdgeSourceTarget struct {
	// Source represents the originating node identifier in the edge type relationship. (optional)
	Source *string `json:"source,omitempty" url:"source,omitempty"`
	// Target represents the target node identifier in the edge type relationship. (optional)
	Target *string `json:"target,omitempty" url:"target,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityEdgeSourceTarget) GetSource() *string {
	if e == nil {
		return nil
	}
	return e.Source
}

func (e *EntityEdgeSourceTarget) GetTarget() *string {
	if e == nil {
		return nil
	}
	return e.Target
}

func (e *EntityEdgeSourceTarget) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityEdgeSourceTarget) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityEdgeSourceTarget
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityEdgeSourceTarget(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityEdgeSourceTarget) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityProperty struct {
	Description string             `json:"description" url:"description"`
	Name        string             `json:"name" url:"name"`
	Type        EntityPropertyType `json:"type" url:"type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityProperty) GetDescription() string {
	if e == nil {
		return ""
	}
	return e.Description
}

func (e *EntityProperty) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

func (e *EntityProperty) GetType() EntityPropertyType {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EntityProperty) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityProperty) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityProperty
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityProperty(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityProperty) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityPropertyType string

const (
	EntityPropertyTypeText    EntityPropertyType = "Text"
	EntityPropertyTypeInt     EntityPropertyType = "Int"
	EntityPropertyTypeFloat   EntityPropertyType = "Float"
	EntityPropertyTypeBoolean EntityPropertyType = "Boolean"
)

func NewEntityPropertyTypeFromString(s string) (EntityPropertyType, error) {
	switch s {
	case "Text":
		return EntityPropertyTypeText, nil
	case "Int":
		return EntityPropertyTypeInt, nil
	case "Float":
		return EntityPropertyTypeFloat, nil
	case "Boolean":
		return EntityPropertyTypeBoolean, nil
	}
	var t EntityPropertyType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EntityPropertyType) Ptr() *EntityPropertyType {
	return &e
}

type EntityType struct {
	Description string            `json:"description" url:"description"`
	Name        string            `json:"name" url:"name"`
	Properties  []*EntityProperty `json:"properties,omitempty" url:"properties,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityType) GetDescription() string {
	if e == nil {
		return ""
	}
	return e.Description
}

func (e *EntityType) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

func (e *EntityType) GetProperties() []*EntityProperty {
	if e == nil {
		return nil
	}
	return e.Properties
}

func (e *EntityType) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityType) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityType) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityTypeResponse struct {
	EdgeTypes   []*EdgeType   `json:"edge_types,omitempty" url:"edge_types,omitempty"`
	EntityTypes []*EntityType `json:"entity_types,omitempty" url:"entity_types,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityTypeResponse) GetEdgeTypes() []*EdgeType {
	if e == nil {
		return nil
	}
	return e.EdgeTypes
}

func (e *EntityTypeResponse) GetEntityTypes() []*EntityType {
	if e == nil {
		return nil
	}
	return e.EntityTypes
}

func (e *EntityTypeResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityTypeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityTypeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityTypeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityTypeResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EpisodeData struct {
	CreatedAt         *string       `json:"created_at,omitempty" url:"created_at,omitempty"`
	Data              string        `json:"data" url:"data"`
	SourceDescription *string       `json:"source_description,omitempty" url:"source_description,omitempty"`
	Type              GraphDataType `json:"type" url:"type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EpisodeData) GetCreatedAt() *string {
	if e == nil {
		return nil
	}
	return e.CreatedAt
}

func (e *EpisodeData) GetData() string {
	if e == nil {
		return ""
	}
	return e.Data
}

func (e *EpisodeData) GetSourceDescription() *string {
	if e == nil {
		return nil
	}
	return e.SourceDescription
}

func (e *EpisodeData) GetType() GraphDataType {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EpisodeData) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EpisodeData) UnmarshalJSON(data []byte) error {
	type unmarshaler EpisodeData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EpisodeData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EpisodeData) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type Graph struct {
	CreatedAt             *string                `json:"created_at,omitempty" url:"created_at,omitempty"`
	Description           *string                `json:"description,omitempty" url:"description,omitempty"`
	FactRatingInstruction *FactRatingInstruction `json:"fact_rating_instruction,omitempty" url:"fact_rating_instruction,omitempty"`
	GraphID               *string                `json:"graph_id,omitempty" url:"graph_id,omitempty"`
	ID                    *int                   `json:"id,omitempty" url:"id,omitempty"`
	Name                  *string                `json:"name,omitempty" url:"name,omitempty"`
	ProjectUUID           *string                `json:"project_uuid,omitempty" url:"project_uuid,omitempty"`
	UUID                  *string                `json:"uuid,omitempty" url:"uuid,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *Graph) GetCreatedAt() *string {
	if g == nil {
		return nil
	}
	return g.CreatedAt
}

func (g *Graph) GetDescription() *string {
	if g == nil {
		return nil
	}
	return g.Description
}

func (g *Graph) GetFactRatingInstruction() *FactRatingInstruction {
	if g == nil {
		return nil
	}
	return g.FactRatingInstruction
}

func (g *Graph) GetGraphID() *string {
	if g == nil {
		return nil
	}
	return g.GraphID
}

func (g *Graph) GetID() *int {
	if g == nil {
		return nil
	}
	return g.ID
}

func (g *Graph) GetName() *string {
	if g == nil {
		return nil
	}
	return g.Name
}

func (g *Graph) GetProjectUUID() *string {
	if g == nil {
		return nil
	}
	return g.ProjectUUID
}

func (g *Graph) GetUUID() *string {
	if g == nil {
		return nil
	}
	return g.UUID
}

func (g *Graph) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *Graph) UnmarshalJSON(data []byte) error {
	type unmarshaler Graph
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = Graph(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *Graph) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GraphListResponse struct {
	Graphs     []*Graph `json:"graphs,omitempty" url:"graphs,omitempty"`
	RowCount   *int     `json:"row_count,omitempty" url:"row_count,omitempty"`
	TotalCount *int     `json:"total_count,omitempty" url:"total_count,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GraphListResponse) GetGraphs() []*Graph {
	if g == nil {
		return nil
	}
	return g.Graphs
}

func (g *GraphListResponse) GetRowCount() *int {
	if g == nil {
		return nil
	}
	return g.RowCount
}

func (g *GraphListResponse) GetTotalCount() *int {
	if g == nil {
		return nil
	}
	return g.TotalCount
}

func (g *GraphListResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GraphListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GraphListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GraphListResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GraphListResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GraphSearchResults struct {
	Edges    []*EntityEdge `json:"edges,omitempty" url:"edges,omitempty"`
	Episodes []*Episode    `json:"episodes,omitempty" url:"episodes,omitempty"`
	Nodes    []*EntityNode `json:"nodes,omitempty" url:"nodes,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GraphSearchResults) GetEdges() []*EntityEdge {
	if g == nil {
		return nil
	}
	return g.Edges
}

func (g *GraphSearchResults) GetEpisodes() []*Episode {
	if g == nil {
		return nil
	}
	return g.Episodes
}

func (g *GraphSearchResults) GetNodes() []*EntityNode {
	if g == nil {
		return nil
	}
	return g.Nodes
}

func (g *GraphSearchResults) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GraphSearchResults) UnmarshalJSON(data []byte) error {
	type unmarshaler GraphSearchResults
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GraphSearchResults(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GraphSearchResults) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GraphSearchScope string

const (
	GraphSearchScopeEdges    GraphSearchScope = "edges"
	GraphSearchScopeNodes    GraphSearchScope = "nodes"
	GraphSearchScopeEpisodes GraphSearchScope = "episodes"
)

func NewGraphSearchScopeFromString(s string) (GraphSearchScope, error) {
	switch s {
	case "edges":
		return GraphSearchScopeEdges, nil
	case "nodes":
		return GraphSearchScopeNodes, nil
	case "episodes":
		return GraphSearchScopeEpisodes, nil
	}
	var t GraphSearchScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GraphSearchScope) Ptr() *GraphSearchScope {
	return &g
}

type PropertyFilter struct {
	// Comparison operator for property filter
	ComparisonOperator ComparisonOperator `json:"comparison_operator" url:"comparison_operator"`
	// Property name to filter on
	PropertyName string `json:"property_name" url:"property_name"`
	// Property value to match on. Accepted types: string, int, float64, bool, or nil.
	// Invalid types (e.g., arrays, objects) will be rejected by validation.
	// Must be non-nil for non-null operators (=, <>, >, <, >=, <=).
	PropertyValue interface{} `json:"property_value,omitempty" url:"property_value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PropertyFilter) GetComparisonOperator() ComparisonOperator {
	if p == nil {
		return ""
	}
	return p.ComparisonOperator
}

func (p *PropertyFilter) GetPropertyName() string {
	if p == nil {
		return ""
	}
	return p.PropertyName
}

func (p *PropertyFilter) GetPropertyValue() interface{} {
	if p == nil {
		return nil
	}
	return p.PropertyValue
}

func (p *PropertyFilter) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PropertyFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler PropertyFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PropertyFilter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PropertyFilter) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Reranker string

const (
	RerankerRrf             Reranker = "rrf"
	RerankerMmr             Reranker = "mmr"
	RerankerNodeDistance    Reranker = "node_distance"
	RerankerEpisodeMentions Reranker = "episode_mentions"
	RerankerCrossEncoder    Reranker = "cross_encoder"
)

func NewRerankerFromString(s string) (Reranker, error) {
	switch s {
	case "rrf":
		return RerankerRrf, nil
	case "mmr":
		return RerankerMmr, nil
	case "node_distance":
		return RerankerNodeDistance, nil
	case "episode_mentions":
		return RerankerEpisodeMentions, nil
	case "cross_encoder":
		return RerankerCrossEncoder, nil
	}
	var t Reranker
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r Reranker) Ptr() *Reranker {
	return &r
}

type SearchFilters struct {
	// 2D array of date filters for the created_at field.
	// The outer array elements are combined with OR logic.
	// The inner array elements are combined with AND logic.
	// Example: [[{">", date1}, {"<", date2}], [{"=", date3}]]
	// This translates to: (created_at > date1 AND created_at < date2) OR (created_at = date3)
	CreatedAt [][]*DateFilter `json:"created_at,omitempty" url:"created_at,omitempty"`
	// List of edge types to filter on
	EdgeTypes []string `json:"edge_types,omitempty" url:"edge_types,omitempty"`
	// List of edge UUIDs to filter on
	EdgeUUIDs []string `json:"edge_uuids,omitempty" url:"edge_uuids,omitempty"`
	// List of edge types to exclude from results
	ExcludeEdgeTypes []string `json:"exclude_edge_types,omitempty" url:"exclude_edge_types,omitempty"`
	// List of node labels to exclude from results
	ExcludeNodeLabels []string `json:"exclude_node_labels,omitempty" url:"exclude_node_labels,omitempty"`
	// 2D array of date filters for the expired_at field.
	// The outer array elements are combined with OR logic.
	// The inner array elements are combined with AND logic.
	// Example: [[{">", date1}, {"<", date2}], [{"=", date3}]]
	// This translates to: (expired_at > date1 AND expired_at < date2) OR (expired_at = date3)
	ExpiredAt [][]*DateFilter `json:"expired_at,omitempty" url:"expired_at,omitempty"`
	// 2D array of date filters for the invalid_at field.
	// The outer array elements are combined with OR logic.
	// The inner array elements are combined with AND logic.
	// Example: [[{">", date1}, {"<", date2}], [{"=", date3}]]
	// This translates to: (invalid_at > date1 AND invalid_at < date2) OR (invalid_at = date3)
	InvalidAt [][]*DateFilter `json:"invalid_at,omitempty" url:"invalid_at,omitempty"`
	// List of node labels to filter on
	NodeLabels []string `json:"node_labels,omitempty" url:"node_labels,omitempty"`
	// List of property filters to apply to nodes and edges
	PropertyFilters []*PropertyFilter `json:"property_filters,omitempty" url:"property_filters,omitempty"`
	// 2D array of date filters for the valid_at field.
	// The outer array elements are combined with OR logic.
	// The inner array elements are combined with AND logic.
	// Example: [[{">", date1}, {"<", date2}], [{"=", date3}]]
	// This translates to: (valid_at > date1 AND valid_at < date2) OR (valid_at = date3)
	ValidAt [][]*DateFilter `json:"valid_at,omitempty" url:"valid_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchFilters) GetCreatedAt() [][]*DateFilter {
	if s == nil {
		return nil
	}
	return s.CreatedAt
}

func (s *SearchFilters) GetEdgeTypes() []string {
	if s == nil {
		return nil
	}
	return s.EdgeTypes
}

func (s *SearchFilters) GetEdgeUUIDs() []string {
	if s == nil {
		return nil
	}
	return s.EdgeUUIDs
}

func (s *SearchFilters) GetExcludeEdgeTypes() []string {
	if s == nil {
		return nil
	}
	return s.ExcludeEdgeTypes
}

func (s *SearchFilters) GetExcludeNodeLabels() []string {
	if s == nil {
		return nil
	}
	return s.ExcludeNodeLabels
}

func (s *SearchFilters) GetExpiredAt() [][]*DateFilter {
	if s == nil {
		return nil
	}
	return s.ExpiredAt
}

func (s *SearchFilters) GetInvalidAt() [][]*DateFilter {
	if s == nil {
		return nil
	}
	return s.InvalidAt
}

func (s *SearchFilters) GetNodeLabels() []string {
	if s == nil {
		return nil
	}
	return s.NodeLabels
}

func (s *SearchFilters) GetPropertyFilters() []*PropertyFilter {
	if s == nil {
		return nil
	}
	return s.PropertyFilters
}

func (s *SearchFilters) GetValidAt() [][]*DateFilter {
	if s == nil {
		return nil
	}
	return s.ValidAt
}

func (s *SearchFilters) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchFilters) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchFilters
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchFilters(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchFilters) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type UpdateGraphRequest struct {
	Description           *string                `json:"description,omitempty" url:"-"`
	FactRatingInstruction *FactRatingInstruction `json:"fact_rating_instruction,omitempty" url:"-"`
	Name                  *string                `json:"name,omitempty" url:"-"`
}
