// This file was auto-generated by Fern from our API Definition.

package zep

type AddMemoryRequest struct {
	// Additional instruction for generating the facts.
	FactInstruction *string `json:"fact_instruction,omitempty" url:"fact_instruction,omitempty"`
	// A list of message objects, where each message contains a role and content.
	Messages []*Message `json:"messages,omitempty" url:"messages,omitempty"`
	// Additional instruction for generating the summary.
	SummaryInstruction *string `json:"summary_instruction,omitempty" url:"summary_instruction,omitempty"`
}

type CreateSessionRequest struct {
	// Optional instruction to use for fact rating.
	FactRatingInstruction *FactRatingInstruction `json:"fact_rating_instruction,omitempty" url:"fact_rating_instruction,omitempty"`
	// The metadata associated with the session.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The unique identifier of the session.
	SessionID string `json:"session_id" url:"session_id"`
	// The unique identifier of the user associated with the session
	UserID *string `json:"user_id,omitempty" url:"user_id,omitempty"`
}

type EndSessionRequest struct {
	Classify    *ClassifySessionRequest `json:"classify,omitempty" url:"classify,omitempty"`
	Instruction *string                 `json:"instruction,omitempty" url:"instruction,omitempty"`
}

type EndSessionsRequest struct {
	Instruction *string  `json:"instruction,omitempty" url:"instruction,omitempty"`
	SessionIDs  []string `json:"session_ids,omitempty" url:"session_ids,omitempty"`
}

type ExtractDataRequest struct {
	// Your current date and time in ISO 8601 format including timezone. This is used for determining relative dates.
	CurrentDateTime *string `json:"current_date_time,omitempty" url:"current_date_time,omitempty"`
	// The number of messages in the chat history from which to extract data
	LastN int `json:"last_n" url:"last_n"`
	// The schema describing the data to be extracted. See Zep's SDKs for more details.
	ModelSchema string `json:"model_schema" url:"model_schema"`
	// Validate that the extracted data is present in the dialog and correct per the field description.
	// Mitigates hallucination, but is slower and may result in false negatives.
	Validate *bool `json:"validate,omitempty" url:"validate,omitempty"`
}

type MemoryGetRequest struct {
	// The type of memory to retrieve: perpetual, summary_retriever, or message_window. Defaults to perpetual.
	MemoryType *MemoryType `json:"-" url:"memoryType,omitempty"`
	// The number of most recent memory entries to retrieve.
	Lastn *int `json:"-" url:"lastn,omitempty"`
	// The minimum rating by which to filter facts
	MinRating *float64 `json:"-" url:"minRating,omitempty"`
}

type MemoryGetSessionFactsRequest struct {
	// Minimum rating by which to filter facts
	MinRating *float64 `json:"-" url:"minRating,omitempty"`
}

type MemoryGetSessionMessagesRequest struct {
	// Limit the number of results returned
	Limit *int `json:"-" url:"limit,omitempty"`
	// Cursor for pagination
	Cursor *int `json:"-" url:"cursor,omitempty"`
}

type MemoryListSessionsRequest struct {
	// Page number for pagination, starting from 1
	PageNumber *int `json:"-" url:"page_number,omitempty"`
	// Number of sessions to retrieve per page
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// Field to order the results by: created_at, updated_at, user_id, session_id
	OrderBy *string `json:"-" url:"order_by,omitempty"`
	// Order direction: true for ascending, false for descending
	Asc *bool `json:"-" url:"asc,omitempty"`
}

type MemorySearchPayload struct {
	// The maximum number of search results to return. Defaults to None (no limit).
	Limit *int `json:"-" url:"limit,omitempty"`
	// Metadata Filter
	Metadata      map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	MinFactRating *float64               `json:"min_fact_rating,omitempty" url:"min_fact_rating,omitempty"`
	MinScore      *float64               `json:"min_score,omitempty" url:"min_score,omitempty"`
	MmrLambda     *float64               `json:"mmr_lambda,omitempty" url:"mmr_lambda,omitempty"`
	SearchScope   *SearchScope           `json:"search_scope,omitempty" url:"search_scope,omitempty"`
	SearchType    *SearchType            `json:"search_type,omitempty" url:"search_type,omitempty"`
	Text          *string                `json:"text,omitempty" url:"text,omitempty"`
}

type SessionSearchQuery struct {
	// The maximum number of search results to return. Defaults to None (no limit).
	Limit         *int     `json:"-" url:"limit,omitempty"`
	MinFactRating *float64 `json:"min_fact_rating,omitempty" url:"min_fact_rating,omitempty"`
	MinScore      *float64 `json:"min_score,omitempty" url:"min_score,omitempty"`
	MmrLambda     *float64 `json:"mmr_lambda,omitempty" url:"mmr_lambda,omitempty"`
	// filter on the metadata
	RecordFilter map[string]interface{} `json:"record_filter,omitempty" url:"record_filter,omitempty"`
	SearchScope  *SearchScope           `json:"search_scope,omitempty" url:"search_scope,omitempty"`
	SearchType   *SearchType            `json:"search_type,omitempty" url:"search_type,omitempty"`
	// the session ids to search
	SessionIDs []string `json:"session_ids,omitempty" url:"session_ids,omitempty"`
	Text       *string  `json:"text,omitempty" url:"text,omitempty"`
	UserID     *string  `json:"user_id,omitempty" url:"user_id,omitempty"`
}

type MemorySynthesizeQuestionRequest struct {
	// The number of messages to use for question synthesis.
	LastNMessages *int `json:"-" url:"lastNMessages,omitempty"`
}

type ModelsMessageMetadataUpdate struct {
	// The metadata to update
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
}

type UpdateSessionRequest struct {
	// Optional instruction to use for fact rating.
	// Fact rating instructions can not be unset.
	FactRatingInstruction *FactRatingInstruction `json:"fact_rating_instruction,omitempty" url:"fact_rating_instruction,omitempty"`
	// The metadata to update
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
}
