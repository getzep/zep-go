// This file was auto-generated by Fern from our API Definition.

package zep

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/getzep/zep-go/v2/core"
)

type AddMemoryRequest struct {
	// Additional instruction for generating the facts. Zep Cloud Only, will be ignored on Community Edition.
	FactInstruction *string `json:"fact_instruction,omitempty" url:"-"`
	// A list of message objects, where each message contains a role and content.
	Messages []*Message `json:"messages,omitempty" url:"-"`
	// Optionally return memory context relevant to the most recent messages.
	ReturnContext *bool `json:"return_context,omitempty" url:"-"`
	// Additional instruction for generating the summary. Zep Cloud Only, will be ignored on Community Edition.
	SummaryInstruction *string `json:"summary_instruction,omitempty" url:"-"`
}

type CreateSessionRequest struct {
	// Optional instruction to use for fact rating.
	FactRatingInstruction *FactRatingInstruction `json:"fact_rating_instruction,omitempty" url:"-"`
	// The metadata associated with the session.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"-"`
	// The unique identifier of the session.
	SessionID string `json:"session_id" url:"-"`
	// The unique identifier of the user associated with the session
	UserID string `json:"user_id" url:"-"`
}

type AddFactsRequest struct {
	Facts []*NewFact `json:"facts,omitempty" url:"-"`
}

type EndSessionRequest struct {
	Classify    *ClassifySessionRequest `json:"classify,omitempty" url:"-"`
	Instruction *string                 `json:"instruction,omitempty" url:"-"`
}

type EndSessionsRequest struct {
	Instruction *string  `json:"instruction,omitempty" url:"-"`
	SessionIDs  []string `json:"session_ids,omitempty" url:"-"`
}

type ExtractDataRequest struct {
	// Your current date and time in ISO 8601 format including timezone. This is used for determining relative dates.
	CurrentDateTime *string `json:"current_date_time,omitempty" url:"-"`
	// The number of messages in the chat history from which to extract data
	LastN int `json:"last_n" url:"-"`
	// The schema describing the data to be extracted. See Zep's SDKs for more details.
	ModelSchema string `json:"model_schema" url:"-"`
	// Validate that the extracted data is present in the dialog and correct per the field description.
	// Mitigates hallucination, but is slower and may result in false negatives.
	Validate *bool `json:"validate,omitempty" url:"-"`
}

type MemoryGetRequest struct {
	// The number of most recent memory entries to retrieve.
	Lastn *int `json:"-" url:"lastn,omitempty"`
	// The minimum rating by which to filter facts
	MinRating *float64 `json:"-" url:"minRating,omitempty"`
}

type MemoryGetSessionFactsRequest struct {
	// Minimum rating by which to filter facts (Zep Cloud only)
	MinRating *float64 `json:"-" url:"minRating,omitempty"`
}

type MemoryGetSessionMessagesRequest struct {
	// Limit the number of results returned
	Limit *int `json:"-" url:"limit,omitempty"`
	// Cursor for pagination
	Cursor *int `json:"-" url:"cursor,omitempty"`
}

type MemoryListSessionsRequest struct {
	// Page number for pagination, starting from 1
	PageNumber *int `json:"-" url:"page_number,omitempty"`
	// Number of sessions to retrieve per page
	PageSize *int `json:"-" url:"page_size,omitempty"`
	// Field to order the results by: created_at, updated_at, user_id, session_id
	OrderBy *string `json:"-" url:"order_by,omitempty"`
	// Order direction: true for ascending, false for descending
	Asc *bool `json:"-" url:"asc,omitempty"`
}

type MemorySearchPayload struct {
	// The maximum number of search results to return. Defaults to None (no limit).
	Limit *int `json:"-" url:"limit,omitempty"`
	// Metadata Filter
	Metadata      map[string]interface{} `json:"metadata,omitempty" url:"-"`
	MinFactRating *float64               `json:"min_fact_rating,omitempty" url:"-"`
	MinScore      *float64               `json:"min_score,omitempty" url:"-"`
	MmrLambda     *float64               `json:"mmr_lambda,omitempty" url:"-"`
	SearchScope   *SearchScope           `json:"search_scope,omitempty" url:"-"`
	SearchType    *SearchType            `json:"search_type,omitempty" url:"-"`
	Text          *string                `json:"text,omitempty" url:"-"`
}

type SessionSearchQuery struct {
	// The maximum number of search results to return. Defaults to None (no limit).
	Limit *int `json:"-" url:"limit,omitempty"`
	// The minimum fact rating to filter on. Only supported on cloud. Will be ignored on Community Edition.
	MinFactRating *float64 `json:"min_fact_rating,omitempty" url:"-"`
	// The minimum score for search results. Only supported on cloud. Will be ignored on Community Edition.
	MinScore *float64 `json:"min_score,omitempty" url:"-"`
	// The lambda parameter for the MMR Reranking Algorithm. Only supported on cloud. Will be ignored on Community Edition.
	MmrLambda *float64 `json:"mmr_lambda,omitempty" url:"-"`
	// Record filter on the metadata. Only supported on cloud. Will be ignored on Community Edition.
	RecordFilter map[string]interface{} `json:"record_filter,omitempty" url:"-"`
	// Search scope. Only supported on cloud. On Community Edition the search scope is always "facts".
	SearchScope *SearchScope `json:"search_scope,omitempty" url:"-"`
	// Search type. Only supported on cloud. Will be ignored on Community Edition.
	SearchType *SearchType `json:"search_type,omitempty" url:"-"`
	// the session ids to search
	SessionIDs []string `json:"session_ids,omitempty" url:"-"`
	// The search text.
	Text string `json:"text" url:"-"`
	// User ID used to determine which sessions to search. Required on Community Edition.
	UserID *string `json:"user_id,omitempty" url:"-"`
}

type MemorySynthesizeQuestionRequest struct {
	// The number of messages to use for question synthesis.
	LastNMessages *int `json:"-" url:"lastNMessages,omitempty"`
}

type AddMemoryResponse struct {
	Context *string `json:"context,omitempty" url:"context,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AddMemoryResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddMemoryResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AddMemoryResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddMemoryResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddMemoryResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ClassifySessionRequest struct {
	// The classes to use for classification.
	Classes []string `json:"classes,omitempty" url:"classes,omitempty"`
	// Custom instruction to use for classification.
	Instruction *string `json:"instruction,omitempty" url:"instruction,omitempty"`
	// The number of session messages to consider for classification. Defaults to 4.
	LastN *int `json:"last_n,omitempty" url:"last_n,omitempty"`
	// The name of the classifier. Will be used to store the classification in session metadata if persist is True.
	Name string `json:"name" url:"name"`
	// Whether to persist the classification to session metadata. Defaults to True.
	Persist *bool `json:"persist,omitempty" url:"persist,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClassifySessionRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClassifySessionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ClassifySessionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClassifySessionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClassifySessionRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type EndSessionResponse struct {
	Classification *SessionClassification `json:"classification,omitempty" url:"classification,omitempty"`
	Session        *Session               `json:"session,omitempty" url:"session,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EndSessionResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EndSessionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EndSessionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EndSessionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EndSessionResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EndSessionsResponse struct {
	Sessions []*Session `json:"sessions,omitempty" url:"sessions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EndSessionsResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EndSessionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EndSessionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EndSessionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EndSessionsResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type FactResponse struct {
	Fact *Fact `json:"fact,omitempty" url:"fact,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FactResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FactResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FactResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FactResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FactResponse) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type Memory struct {
	// Memory context containing relevant facts and entities for the session. Can be put into the prompt directly.
	Context *string `json:"context,omitempty" url:"context,omitempty"`
	// Most recent list of facts derived from the session. (cloud only)
	// Deprecated: Facts will be deprecated in future releases and relevant_facts should be used instead.
	Facts []string `json:"facts,omitempty" url:"facts,omitempty"`
	// A list of message objects, where each message contains a role and content. Only last_n messages will be returned
	Messages []*Message `json:"messages,omitempty" url:"messages,omitempty"`
	// A dictionary containing metadata associated with the memory.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Most relevant facts to the recent messages in the session.
	RelevantFacts []*Fact `json:"relevant_facts,omitempty" url:"relevant_facts,omitempty"`
	// The most recent summary before last nth message. (cloud only)
	Summary *Summary `json:"summary,omitempty" url:"summary,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Memory) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Memory) UnmarshalJSON(data []byte) error {
	type unmarshaler Memory
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Memory(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Memory) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MemorySearchResult struct {
	Message  *Message               `json:"message,omitempty" url:"message,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Score    *float64               `json:"score,omitempty" url:"score,omitempty"`
	Summary  *Summary               `json:"summary,omitempty" url:"summary,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MemorySearchResult) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MemorySearchResult) UnmarshalJSON(data []byte) error {
	type unmarshaler MemorySearchResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MemorySearchResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MemorySearchResult) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Message struct {
	// The content of the message.
	Content string `json:"content" url:"content"`
	// The timestamp of when the message was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The metadata associated with the message.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The role of the sender of the message (e.g., "user", "assistant").
	Role *string `json:"role,omitempty" url:"role,omitempty"`
	// The type of the role (e.g., "user", "system").
	RoleType RoleType `json:"role_type" url:"role_type"`
	// The number of tokens in the message.
	TokenCount *int `json:"token_count,omitempty" url:"token_count,omitempty"`
	// The timestamp of when the message was last updated.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The unique identifier of the message.
	UUID *string `json:"uuid,omitempty" url:"uuid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Message) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Message) UnmarshalJSON(data []byte) error {
	type unmarshaler Message
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Message(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Message) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MessageListResponse struct {
	// A list of message objects.
	Messages []*Message `json:"messages,omitempty" url:"messages,omitempty"`
	// The number of messages returned.
	RowCount *int `json:"row_count,omitempty" url:"row_count,omitempty"`
	// The total number of messages.
	TotalCount *int `json:"total_count,omitempty" url:"total_count,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MessageListResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MessageListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MessageListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MessageListResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MessageListResponse) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NewFact struct {
	Fact *string `json:"fact,omitempty" url:"fact,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (n *NewFact) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NewFact) UnmarshalJSON(data []byte) error {
	type unmarshaler NewFact
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NewFact(value)

	extraProperties, err := core.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties

	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NewFact) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type Question struct {
	Question *string `json:"question,omitempty" url:"question,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *Question) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *Question) UnmarshalJSON(data []byte) error {
	type unmarshaler Question
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = Question(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = json.RawMessage(data)
	return nil
}

func (q *Question) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

type RoleType string

const (
	RoleTypeNoRole        RoleType = "norole"
	RoleTypeSystemRole    RoleType = "system"
	RoleTypeAssistantRole RoleType = "assistant"
	RoleTypeUserRole      RoleType = "user"
	RoleTypeFunctionRole  RoleType = "function"
	RoleTypeToolRole      RoleType = "tool"
)

func NewRoleTypeFromString(s string) (RoleType, error) {
	switch s {
	case "norole":
		return RoleTypeNoRole, nil
	case "system":
		return RoleTypeSystemRole, nil
	case "assistant":
		return RoleTypeAssistantRole, nil
	case "user":
		return RoleTypeUserRole, nil
	case "function":
		return RoleTypeFunctionRole, nil
	case "tool":
		return RoleTypeToolRole, nil
	}
	var t RoleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RoleType) Ptr() *RoleType {
	return &r
}

type SearchScope string

const (
	SearchScopeMessages SearchScope = "messages"
	SearchScopeSummary  SearchScope = "summary"
	SearchScopeFacts    SearchScope = "facts"
)

func NewSearchScopeFromString(s string) (SearchScope, error) {
	switch s {
	case "messages":
		return SearchScopeMessages, nil
	case "summary":
		return SearchScopeSummary, nil
	case "facts":
		return SearchScopeFacts, nil
	}
	var t SearchScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchScope) Ptr() *SearchScope {
	return &s
}

type SessionClassification struct {
	Class *string `json:"class,omitempty" url:"class,omitempty"`
	Label *string `json:"label,omitempty" url:"label,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SessionClassification) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SessionClassification) UnmarshalJSON(data []byte) error {
	type unmarshaler SessionClassification
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SessionClassification(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SessionClassification) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SessionListResponse struct {
	ResponseCount *int       `json:"response_count,omitempty" url:"response_count,omitempty"`
	Sessions      []*Session `json:"sessions,omitempty" url:"sessions,omitempty"`
	TotalCount    *int       `json:"total_count,omitempty" url:"total_count,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SessionListResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SessionListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SessionListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SessionListResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SessionListResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SessionSearchResponse struct {
	Results []*SessionSearchResult `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SessionSearchResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SessionSearchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SessionSearchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SessionSearchResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SessionSearchResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SessionSearchResult struct {
	Fact      *Fact    `json:"fact,omitempty" url:"fact,omitempty"`
	Message   *Message `json:"message,omitempty" url:"message,omitempty"`
	Score     *float64 `json:"score,omitempty" url:"score,omitempty"`
	SessionID *string  `json:"session_id,omitempty" url:"session_id,omitempty"`
	Summary   *Summary `json:"summary,omitempty" url:"summary,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SessionSearchResult) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SessionSearchResult) UnmarshalJSON(data []byte) error {
	type unmarshaler SessionSearchResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SessionSearchResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SessionSearchResult) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Summary struct {
	// The content of the summary.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// The timestamp of when the summary was created.
	CreatedAt           *string                `json:"created_at,omitempty" url:"created_at,omitempty"`
	Metadata            map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	RelatedMessageUUIDs []string               `json:"related_message_uuids,omitempty" url:"related_message_uuids,omitempty"`
	// The number of tokens in the summary.
	TokenCount *int `json:"token_count,omitempty" url:"token_count,omitempty"`
	// The unique identifier of the summary.
	UUID *string `json:"uuid,omitempty" url:"uuid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Summary) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Summary) UnmarshalJSON(data []byte) error {
	type unmarshaler Summary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Summary(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Summary) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SummaryListResponse struct {
	RowCount   *int       `json:"row_count,omitempty" url:"row_count,omitempty"`
	Summaries  []*Summary `json:"summaries,omitempty" url:"summaries,omitempty"`
	TotalCount *int       `json:"total_count,omitempty" url:"total_count,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SummaryListResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SummaryListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SummaryListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SummaryListResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SummaryListResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ModelsMessageMetadataUpdate struct {
	// The metadata to update
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"-"`
}

type UpdateSessionRequest struct {
	// Optional instruction to use for fact rating.
	// Fact rating instructions can not be unset.
	FactRatingInstruction *FactRatingInstruction `json:"fact_rating_instruction,omitempty" url:"-"`
	// The metadata to update
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"-"`
}
