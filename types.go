// Code generated by Fern. DO NOT EDIT.

package zep

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/getzep/zep-go/v3/internal"
)

type APIError struct {
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *APIError) GetMessage() *string {
	if a == nil {
		return nil
	}
	return a.Message
}

func (a *APIError) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *APIError) UnmarshalJSON(data []byte) error {
	type unmarshaler APIError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = APIError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *APIError) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AddFactsRequest = interface{}

type AddMemoryRequest = interface{}

type AddMemoryResponse = interface{}

type AddedFact = interface{}

type AssistantRole = interface{}

type ClassifySessionRequest = interface{}

type ClassifySessionResponse = interface{}

type CommunityNode = interface{}

type CreateDocumentCollectionRequest = interface{}

type CreateDocumentRequest = interface{}

type CreateGroupRequest = interface{}

type CreateSessionRequest = interface{}

type DocumentCollectionResponse = interface{}

type DocumentResponse = interface{}

type DocumentSearchPayload = interface{}

type DocumentSearchResult = interface{}

type DocumentSearchResultPage = interface{}

type EndSessionRequest = interface{}

type EndSessionResponse = interface{}

type EndSessionsRequest = interface{}

type EndSessionsResponse = interface{}

type EntityEdge struct {
	// Additional attributes of the edge. Dependent on edge types
	Attributes map[string]interface{} `json:"attributes,omitempty" url:"attributes,omitempty"`
	// Creation time of the edge
	CreatedAt string `json:"created_at" url:"created_at"`
	// List of episode ids that reference these entity edges
	Episodes []string `json:"episodes,omitempty" url:"episodes,omitempty"`
	// Datetime of when the node was invalidated
	ExpiredAt *string `json:"expired_at,omitempty" url:"expired_at,omitempty"`
	// Fact representing the edge and nodes that it connects
	Fact string `json:"fact" url:"fact"`
	// Datetime of when the fact stopped being true
	InvalidAt *string `json:"invalid_at,omitempty" url:"invalid_at,omitempty"`
	// Name of the edge, relation name
	Name string `json:"name" url:"name"`
	// Relevance is an experimental rank-aligned score in [0,1] derived from Score via logit transformation.
	// Only populated when using cross_encoder reranker; omitted for other reranker types (e.g., RRF).
	Relevance *float64 `json:"relevance,omitempty" url:"relevance,omitempty"`
	// Score is the reranker output: sigmoid-distributed logits [0,1] when using cross_encoder reranker, or RRF ordinal rank when using rrf reranker
	Score *float64 `json:"score,omitempty" url:"score,omitempty"`
	// UUID of the source node
	SourceNodeUUID string `json:"source_node_uuid" url:"source_node_uuid"`
	// UUID of the target node
	TargetNodeUUID string `json:"target_node_uuid" url:"target_node_uuid"`
	// UUID of the edge
	UUID string `json:"uuid" url:"uuid"`
	// Datetime of when the fact became true
	ValidAt *string `json:"valid_at,omitempty" url:"valid_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityEdge) GetAttributes() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.Attributes
}

func (e *EntityEdge) GetCreatedAt() string {
	if e == nil {
		return ""
	}
	return e.CreatedAt
}

func (e *EntityEdge) GetEpisodes() []string {
	if e == nil {
		return nil
	}
	return e.Episodes
}

func (e *EntityEdge) GetExpiredAt() *string {
	if e == nil {
		return nil
	}
	return e.ExpiredAt
}

func (e *EntityEdge) GetFact() string {
	if e == nil {
		return ""
	}
	return e.Fact
}

func (e *EntityEdge) GetInvalidAt() *string {
	if e == nil {
		return nil
	}
	return e.InvalidAt
}

func (e *EntityEdge) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

func (e *EntityEdge) GetRelevance() *float64 {
	if e == nil {
		return nil
	}
	return e.Relevance
}

func (e *EntityEdge) GetScore() *float64 {
	if e == nil {
		return nil
	}
	return e.Score
}

func (e *EntityEdge) GetSourceNodeUUID() string {
	if e == nil {
		return ""
	}
	return e.SourceNodeUUID
}

func (e *EntityEdge) GetTargetNodeUUID() string {
	if e == nil {
		return ""
	}
	return e.TargetNodeUUID
}

func (e *EntityEdge) GetUUID() string {
	if e == nil {
		return ""
	}
	return e.UUID
}

func (e *EntityEdge) GetValidAt() *string {
	if e == nil {
		return nil
	}
	return e.ValidAt
}

func (e *EntityEdge) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityEdge) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityEdge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityEdge(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityEdge) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityNode struct {
	// Additional attributes of the node. Dependent on node labels
	Attributes map[string]interface{} `json:"attributes,omitempty" url:"attributes,omitempty"`
	// Creation time of the node
	CreatedAt string `json:"created_at" url:"created_at"`
	// Labels associated with the node
	Labels []string `json:"labels,omitempty" url:"labels,omitempty"`
	// Name of the node
	Name string `json:"name" url:"name"`
	// Relevance is an experimental rank-aligned score in [0,1] derived from Score via logit transformation.
	// Only populated when using cross_encoder reranker; omitted for other reranker types (e.g., RRF).
	Relevance *float64 `json:"relevance,omitempty" url:"relevance,omitempty"`
	// Score is the reranker output: sigmoid-distributed logits [0,1] when using cross_encoder reranker, or RRF ordinal rank when using rrf reranker
	Score *float64 `json:"score,omitempty" url:"score,omitempty"`
	// Regional summary of surrounding edges
	Summary string `json:"summary" url:"summary"`
	// UUID of the node
	UUID string `json:"uuid" url:"uuid"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityNode) GetAttributes() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.Attributes
}

func (e *EntityNode) GetCreatedAt() string {
	if e == nil {
		return ""
	}
	return e.CreatedAt
}

func (e *EntityNode) GetLabels() []string {
	if e == nil {
		return nil
	}
	return e.Labels
}

func (e *EntityNode) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

func (e *EntityNode) GetRelevance() *float64 {
	if e == nil {
		return nil
	}
	return e.Relevance
}

func (e *EntityNode) GetScore() *float64 {
	if e == nil {
		return nil
	}
	return e.Score
}

func (e *EntityNode) GetSummary() string {
	if e == nil {
		return ""
	}
	return e.Summary
}

func (e *EntityNode) GetUUID() string {
	if e == nil {
		return ""
	}
	return e.UUID
}

func (e *EntityNode) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityNode) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityNode(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityNode) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type Episode struct {
	Content   string                 `json:"content" url:"content"`
	CreatedAt string                 `json:"created_at" url:"created_at"`
	Metadata  map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Processed *bool                  `json:"processed,omitempty" url:"processed,omitempty"`
	// Relevance is an experimental rank-aligned score in [0,1] derived from Score via logit transformation.
	// Only populated when using cross_encoder reranker; omitted for other reranker types (e.g., RRF).
	Relevance *float64 `json:"relevance,omitempty" url:"relevance,omitempty"`
	// Optional role, will only be present if the episode was created using memory.add API
	Role *string `json:"role,omitempty" url:"role,omitempty"`
	// Optional role_type, will only be present if the episode was created using memory.add API
	RoleType *RoleType `json:"role_type,omitempty" url:"role_type,omitempty"`
	// Score is the reranker output: sigmoid-distributed logits [0,1] when using cross_encoder reranker, or RRF ordinal rank when using rrf reranker
	Score             *float64       `json:"score,omitempty" url:"score,omitempty"`
	Source            *GraphDataType `json:"source,omitempty" url:"source,omitempty"`
	SourceDescription *string        `json:"source_description,omitempty" url:"source_description,omitempty"`
	// Optional thread ID, will be present if the episode is part of a thread
	ThreadID *string `json:"thread_id,omitempty" url:"thread_id,omitempty"`
	UUID     string  `json:"uuid" url:"uuid"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Episode) GetContent() string {
	if e == nil {
		return ""
	}
	return e.Content
}

func (e *Episode) GetCreatedAt() string {
	if e == nil {
		return ""
	}
	return e.CreatedAt
}

func (e *Episode) GetMetadata() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *Episode) GetProcessed() *bool {
	if e == nil {
		return nil
	}
	return e.Processed
}

func (e *Episode) GetRelevance() *float64 {
	if e == nil {
		return nil
	}
	return e.Relevance
}

func (e *Episode) GetRole() *string {
	if e == nil {
		return nil
	}
	return e.Role
}

func (e *Episode) GetRoleType() *RoleType {
	if e == nil {
		return nil
	}
	return e.RoleType
}

func (e *Episode) GetScore() *float64 {
	if e == nil {
		return nil
	}
	return e.Score
}

func (e *Episode) GetSource() *GraphDataType {
	if e == nil {
		return nil
	}
	return e.Source
}

func (e *Episode) GetSourceDescription() *string {
	if e == nil {
		return nil
	}
	return e.SourceDescription
}

func (e *Episode) GetThreadID() *string {
	if e == nil {
		return nil
	}
	return e.ThreadID
}

func (e *Episode) GetUUID() string {
	if e == nil {
		return ""
	}
	return e.UUID
}

func (e *Episode) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Episode) UnmarshalJSON(data []byte) error {
	type unmarshaler Episode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Episode(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Episode) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EpisodeMentions struct {
	Edges []*EntityEdge `json:"edges,omitempty" url:"edges,omitempty"`
	Nodes []*EntityNode `json:"nodes,omitempty" url:"nodes,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EpisodeMentions) GetEdges() []*EntityEdge {
	if e == nil {
		return nil
	}
	return e.Edges
}

func (e *EpisodeMentions) GetNodes() []*EntityNode {
	if e == nil {
		return nil
	}
	return e.Nodes
}

func (e *EpisodeMentions) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EpisodeMentions) UnmarshalJSON(data []byte) error {
	type unmarshaler EpisodeMentions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EpisodeMentions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EpisodeMentions) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EpisodeResponse struct {
	Episodes []*Episode `json:"episodes,omitempty" url:"episodes,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EpisodeResponse) GetEpisodes() []*Episode {
	if e == nil {
		return nil
	}
	return e.Episodes
}

func (e *EpisodeResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EpisodeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EpisodeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EpisodeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EpisodeResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EpisodeType = interface{}

type ExtractDataRequest = interface{}

type Fact = interface{}

type FactRatingExamples struct {
	High   *string `json:"high,omitempty" url:"high,omitempty"`
	Low    *string `json:"low,omitempty" url:"low,omitempty"`
	Medium *string `json:"medium,omitempty" url:"medium,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FactRatingExamples) GetHigh() *string {
	if f == nil {
		return nil
	}
	return f.High
}

func (f *FactRatingExamples) GetLow() *string {
	if f == nil {
		return nil
	}
	return f.Low
}

func (f *FactRatingExamples) GetMedium() *string {
	if f == nil {
		return nil
	}
	return f.Medium
}

func (f *FactRatingExamples) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FactRatingExamples) UnmarshalJSON(data []byte) error {
	type unmarshaler FactRatingExamples
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FactRatingExamples(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FactRatingExamples) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FactRatingInstruction struct {
	// Examples is a list of examples that demonstrate how facts might be rated based on your instruction. You should provide
	// an example of a highly rated example, a low rated example, and a medium (or in between example). For example, if you are rating
	// based on relevance to a trip planning application, your examples might be:
	// High: "Joe's dream vacation is Bali"
	// Medium: "Joe has a fear of flying",
	// Low: "Joe's favorite food is Japanese",
	Examples *FactRatingExamples `json:"examples,omitempty" url:"examples,omitempty"`
	// A string describing how to rate facts as they apply to your application. A trip planning application may
	// use something like "relevancy to planning a trip, the user's preferences when traveling,
	// or the user's travel history."
	Instruction *string `json:"instruction,omitempty" url:"instruction,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FactRatingInstruction) GetExamples() *FactRatingExamples {
	if f == nil {
		return nil
	}
	return f.Examples
}

func (f *FactRatingInstruction) GetInstruction() *string {
	if f == nil {
		return nil
	}
	return f.Instruction
}

func (f *FactRatingInstruction) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FactRatingInstruction) UnmarshalJSON(data []byte) error {
	type unmarshaler FactRatingInstruction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FactRatingInstruction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FactRatingInstruction) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FactResponse = interface{}

type FactsResponse = interface{}

type FunctionRole = interface{}

type GetDocumentListRequest = interface{}

type GraphDataType string

const (
	GraphDataTypeText    GraphDataType = "text"
	GraphDataTypeJSON    GraphDataType = "json"
	GraphDataTypeMessage GraphDataType = "message"
)

func NewGraphDataTypeFromString(s string) (GraphDataType, error) {
	switch s {
	case "text":
		return GraphDataTypeText, nil
	case "json":
		return GraphDataTypeJSON, nil
	case "message":
		return GraphDataTypeMessage, nil
	}
	var t GraphDataType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GraphDataType) Ptr() *GraphDataType {
	return &g
}

type GraphEdgesRequest struct {
	// Maximum number of items to return
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// UUID based cursor, used for pagination. Should be the UUID of the last item in the previous page
	UUIDCursor *string `json:"uuid_cursor,omitempty" url:"uuid_cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GraphEdgesRequest) GetLimit() *int {
	if g == nil {
		return nil
	}
	return g.Limit
}

func (g *GraphEdgesRequest) GetUUIDCursor() *string {
	if g == nil {
		return nil
	}
	return g.UUIDCursor
}

func (g *GraphEdgesRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GraphEdgesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GraphEdgesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GraphEdgesRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GraphEdgesRequest) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GraphNodesRequest struct {
	// Maximum number of items to return
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// UUID based cursor, used for pagination. Should be the UUID of the last item in the previous page
	UUIDCursor *string `json:"uuid_cursor,omitempty" url:"uuid_cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GraphNodesRequest) GetLimit() *int {
	if g == nil {
		return nil
	}
	return g.Limit
}

func (g *GraphNodesRequest) GetUUIDCursor() *string {
	if g == nil {
		return nil
	}
	return g.UUIDCursor
}

func (g *GraphNodesRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GraphNodesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GraphNodesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GraphNodesRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GraphNodesRequest) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type Group = interface{}

type GroupListResponse = interface{}

type Memory = interface{}

type MemorySearchPayload = interface{}

type MemorySearchResult = interface{}

type MemoryType string

const (
	MemoryTypePerpetual        MemoryType = "perpetual"
	MemoryTypeSummaryRetriever MemoryType = "summary_retriever"
	MemoryTypeMessageWindow    MemoryType = "message_window"
)

func NewMemoryTypeFromString(s string) (MemoryType, error) {
	switch s {
	case "perpetual":
		return MemoryTypePerpetual, nil
	case "summary_retriever":
		return MemoryTypeSummaryRetriever, nil
	case "message_window":
		return MemoryTypeMessageWindow, nil
	}
	var t MemoryType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MemoryType) Ptr() *MemoryType {
	return &m
}

type Message struct {
	// The content of the message.
	Content string `json:"content" url:"content"`
	// The timestamp of when the message was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The metadata associated with the message.
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Customizable name of the sender of the message (e.g., "john", "sales_agent").
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Whether the message has been processed.
	Processed *bool `json:"processed,omitempty" url:"processed,omitempty"`
	// The role of message sender (e.g., "user", "system").
	Role RoleType `json:"role" url:"role"`
	// The unique identifier of the message.
	UUID *string `json:"uuid,omitempty" url:"uuid,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *Message) GetContent() string {
	if m == nil {
		return ""
	}
	return m.Content
}

func (m *Message) GetCreatedAt() *string {
	if m == nil {
		return nil
	}
	return m.CreatedAt
}

func (m *Message) GetMetadata() map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.Metadata
}

func (m *Message) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *Message) GetProcessed() *bool {
	if m == nil {
		return nil
	}
	return m.Processed
}

func (m *Message) GetRole() RoleType {
	if m == nil {
		return ""
	}
	return m.Role
}

func (m *Message) GetUUID() *string {
	if m == nil {
		return nil
	}
	return m.UUID
}

func (m *Message) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Message) UnmarshalJSON(data []byte) error {
	type unmarshaler Message
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Message(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *Message) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NewFact = interface{}

type NoRole = interface{}

type Question = interface{}

type RoleType string

const (
	RoleTypeNoRole        RoleType = "norole"
	RoleTypeSystemRole    RoleType = "system"
	RoleTypeAssistantRole RoleType = "assistant"
	RoleTypeUserRole      RoleType = "user"
	RoleTypeFunctionRole  RoleType = "function"
	RoleTypeToolRole      RoleType = "tool"
)

func NewRoleTypeFromString(s string) (RoleType, error) {
	switch s {
	case "norole":
		return RoleTypeNoRole, nil
	case "system":
		return RoleTypeSystemRole, nil
	case "assistant":
		return RoleTypeAssistantRole, nil
	case "user":
		return RoleTypeUserRole, nil
	case "function":
		return RoleTypeFunctionRole, nil
	case "tool":
		return RoleTypeToolRole, nil
	}
	var t RoleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RoleType) Ptr() *RoleType {
	return &r
}

type SearchScope = interface{}

type SearchType = interface{}

type Session = interface{}

type SessionClassification = interface{}

type SessionFactRatingExamples = interface{}

type SessionFactRatingInstruction = interface{}

type SessionListResponse = interface{}

type SessionSearchQuery = interface{}

type SessionSearchResponse = interface{}

type SessionSearchResult = interface{}

type SuccessResponse struct {
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SuccessResponse) GetMessage() *string {
	if s == nil {
		return nil
	}
	return s.Message
}

func (s *SuccessResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SuccessResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SuccessResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SuccessResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SuccessResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Summary = interface{}

type SummaryListResponse = interface{}

type SystemRole = interface{}

type Thread struct {
	CreatedAt   *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	ProjectUUID *string `json:"project_uuid,omitempty" url:"project_uuid,omitempty"`
	ThreadID    *string `json:"thread_id,omitempty" url:"thread_id,omitempty"`
	UserID      *string `json:"user_id,omitempty" url:"user_id,omitempty"`
	UUID        *string `json:"uuid,omitempty" url:"uuid,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Thread) GetCreatedAt() *string {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *Thread) GetProjectUUID() *string {
	if t == nil {
		return nil
	}
	return t.ProjectUUID
}

func (t *Thread) GetThreadID() *string {
	if t == nil {
		return nil
	}
	return t.ThreadID
}

func (t *Thread) GetUserID() *string {
	if t == nil {
		return nil
	}
	return t.UserID
}

func (t *Thread) GetUUID() *string {
	if t == nil {
		return nil
	}
	return t.UUID
}

func (t *Thread) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Thread) UnmarshalJSON(data []byte) error {
	type unmarshaler Thread
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Thread(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Thread) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolRole = interface{}

type UpdateDocumentCollectionRequest = interface{}

type UpdateDocumentListRequest = interface{}

type UpdateDocumentRequest = interface{}

type UpdateGroupRequest = interface{}

type UpdateSessionRequest = interface{}

type UserRole = interface{}
